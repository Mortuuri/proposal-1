# Smart Contract - Computor Controled Fund (CCF) - 2024-09-09
To allow a decentralized funding mechanics the Qubic core team suggests to create a dedicated Smart Contract.

## Proposal
Allow the CCF Smart Contract to be deployed on Qubic. Allow the future adoption of the SC if it is requested by the community or the computors.
This is an infrastructure smart contract. It will **not** generate any revenue for shareholders. The fees generated by the use of the SC are **burned**.

### Available Options
> Option 1: Yes, allow

> Option 2: No

## Details about the Smart Contract

### Funding
- **Everyone** can donate Qubic to the SC
- **Computors** can donate a fixed percentage of their revenue if they wish

### Distribution
- **Everyone** can request funds by creating a proposal to the SC
- Proposals are valid for **one** epoch
- **Computors** can vote on the proposals for the whole epoch; if accepted, the payout is done in `END_EPOCH`; if declined, no payout happens
- Payouts are **not** recurring

### Technical Implementations
- Every proposal costs a fee; the current fee is set to **1mio Qubic**
- Maximum 100 proposals per Epoch can be accepted
- The SC will store the last **128 success** proposals for history purposes
- Long time archive have to be built outside of SC/Core
- The proposal fee will be **burned**
- One Address can only add one proposal per Epoch
- a proposal can only be approved if at least **451** computor votes are casted
- every proposal has the option **"no transfer/no change"**, this allowes computors to express their dislike
- Computors can **change** their vote at any time during the epoch in which the proposal is running

### Governance
- Due to the use of this SC, the CCF is completely distributed. **No** single entity can control those funds.
- The amount of proposal slots per epoch and the high of the fee should be choosen that blocking all slots is to costly for a potential blocking attack
- The proposal fee should be adjustable in the future according to the price development of Qubic


### Technical implementation
The current source code can be found here: https://github.com/qubic/core/blob/develop/src/contracts/ComputorControlledFund.h

Please find the current implementation details are below:

```c++
using namespace QPI;

struct CCF2 
{
};

struct CCF : public ContractBase
{
	//----------------------------------------------------------------------------
	// Define common types

	// Proposal data type. We only support yes/no voting. Complex projects should be broken down into milestones
	// and apply for funding multiple times.
	typedef ProposalDataYesNo ProposalDataT;

	// Anyone can set a proposal, but only computors have right vote.
	typedef ProposalByAnyoneVotingByComputors<100> ProposersAndVotersT;

	// Proposal and voting storage type
	typedef ProposalVoting<ProposersAndVotersT, ProposalDataT> ProposalVotingT;

	struct Success_output
	{
		bool okay;
	};

	struct LatestTransfersEntry
	{
		id destination;
		array<uint8, 256> url;
		sint64 amount;
		uint32 tick;
		bool success;
	};

	typedef array<LatestTransfersEntry, 128> LatestTransfersT;

private:
	//----------------------------------------------------------------------------
	// Define state
	ProposalVotingT proposals;

	LatestTransfersT latestTransfers;
	uint8 lastTransfersNextOverwriteIdx;

	uint32 setProposalFee;

	//----------------------------------------------------------------------------
	// Define private procedures and functions with input and output


public:
	//----------------------------------------------------------------------------
	// Define public procedures and functions with input and output

	typedef ProposalDataT SetProposal_input;
	typedef Success_output SetProposal_output;

	PUBLIC_PROCEDURE(SetProposal)

		if (qpi.invocationReward() < state.setProposalFee)
		{
			// Invocation reward not sufficient, undo payment and cancel
			if (qpi.invocationReward() > 0)
			{
				qpi.transfer(qpi.invocator(), qpi.invocationReward());
			}
			output.okay = false;
			return;
		}
		else if (qpi.invocationReward() > state.setProposalFee)
		{
			// Invocation greater than fee, pay back difference
			qpi.transfer(qpi.invocator(), qpi.invocationReward() - state.setProposalFee);
		}

		// Burn invocation reward
		qpi.burn(qpi.invocationReward());

		// Check requirements for proposals in this contract
		if (ProposalTypes::cls(input.type) != ProposalTypes::Class::Transfer)
		{
			// Only transfer proposals are allowed
			output.okay = false;
			return;
		}

		// Try to set proposal (checks originators rights and general validity of input proposal)
		output.okay = qpi(state.proposals).setProposal(qpi.originator(), input);
	_


	struct GetProposalIndices_input
	{
		bit activeProposals;		// Set true to return indices of active proposals, false for proposals of prior epochs
		sint32 prevProposalIndex;   // Set -1 to start getting indices. If returned index array is full, call again with highest index returned.
	};
	struct GetProposalIndices_output
	{
		uint16 numOfIndices;		// Number of valid entries in indices. Call again if it is 64.
		array<uint16, 64> indices;	// Requested proposal indices. Valid entries are in range 0 ... (numOfIndices - 1).
	};

	PUBLIC_FUNCTION(GetProposalIndices)
		if (input.activeProposals)
		{
			// Return proposals that are open for voting in current epoch
			// (output is initalized with zeros by contract system)
			while ((input.prevProposalIndex = qpi(state.proposals).nextProposalIndex(input.prevProposalIndex, qpi.epoch())) >= 0)
			{
				output.indices.set(output.numOfIndices, input.prevProposalIndex);
				++output.numOfIndices;

				if (output.numOfIndices == output.indices.capacity())
					break;
			}
		}
		else
		{
			// Return proposals of previous epochs not overwritten yet
			// (output is initalized with zeros by contract system)
			while ((input.prevProposalIndex = qpi(state.proposals).nextFinishedProposalIndex(input.prevProposalIndex)) >= 0)
			{
				output.indices.set(output.numOfIndices, input.prevProposalIndex);
				++output.numOfIndices;

				if (output.numOfIndices == output.indices.capacity())
					break;
			}
		}
	_


	struct GetProposal_input
	{
		uint16 proposalIndex;
	};
	struct GetProposal_output
	{
		bit okay;
		uint8 _padding0[7];
		id proposerPubicKey;
		ProposalDataT proposal;
	};

	PUBLIC_FUNCTION(GetProposal)
		output.proposerPubicKey = qpi(state.proposals).proposerId(input.proposalIndex);
		output.okay = qpi(state.proposals).getProposal(input.proposalIndex, output.proposal);
	_


	typedef ProposalSingleVoteDataV1 Vote_input;
	typedef Success_output Vote_output;

	PUBLIC_PROCEDURE(Vote)
		// For voting, there is no fee
		if (qpi.invocationReward() > 0)
		{
			// Pay back invocation reward
			qpi.transfer(qpi.invocator(), qpi.invocationReward());
		}
		
		// Try to vote (checks right to vote and match with proposal)
		output.okay = qpi(state.proposals).vote(qpi.originator(), input);
	_


	struct GetVote_input
	{
		id voter;
		uint16 proposalIndex;
	};
	struct GetVote_output
	{
		bit okay;
		ProposalSingleVoteDataV1 vote;
	};

	PUBLIC_FUNCTION(GetVote)
		output.okay = qpi(state.proposals).getVote(
			input.proposalIndex,
			qpi(state.proposals).voterIndex(input.voter),
			output.vote);
	_


	struct GetVotingResults_input
	{
		uint16 proposalIndex;
	};
	struct GetVotingResults_output
	{
		bit okay;
		ProposalSummarizedVotingDataV1 results;
	};

	PUBLIC_FUNCTION(GetVotingResults)
		output.okay = qpi(state.proposals).getVotingSummary(
			input.proposalIndex, output.results);
	_


	typedef NoData GetLatestTransfers_input;
	typedef LatestTransfersT GetLatestTransfers_output;

	PUBLIC_FUNCTION(GetLatestTransfers)
		output = state.latestTransfers;
	_


	typedef NoData GetProposalFee_input;
	struct GetProposalFee_output
	{
		uint32 proposalFee; // Amount of qus
	};

	PUBLIC_FUNCTION(GetProposalFee)
		output.proposalFee = state.setProposalFee;
	_


	REGISTER_USER_FUNCTIONS_AND_PROCEDURES
		REGISTER_USER_FUNCTION(GetProposalIndices, 1);
		REGISTER_USER_FUNCTION(GetProposal, 2);
		REGISTER_USER_FUNCTION(GetVote, 3);
		REGISTER_USER_FUNCTION(GetVotingResults, 4);
		REGISTER_USER_FUNCTION(GetLatestTransfers, 5);
		REGISTER_USER_FUNCTION(GetProposalFee, 6);

		REGISTER_USER_PROCEDURE(SetProposal, 1);
		REGISTER_USER_PROCEDURE(Vote, 2);
	_


	INITIALIZE
		state.setProposalFee = 1000000;
	_


	struct END_EPOCH_locals
	{
		sint32 proposalIndex;
		ProposalDataT proposal;
		ProposalSummarizedVotingDataV1 results;
		LatestTransfersEntry transfer;
	};

	END_EPOCH_WITH_LOCALS
		// Analyze transfer proposal results

		// Iterate all proposals that were open for voting in this epoch ...
		locals.proposalIndex = -1;
		while ((locals.proposalIndex = qpi(state.proposals).nextProposalIndex(locals.proposalIndex, qpi.epoch())) >= 0)
		{
			if (!qpi(state.proposals).getProposal(locals.proposalIndex, locals.proposal))
				continue;

			// ... and have transfer proposal type
			if (ProposalTypes::cls(locals.proposal.type) == ProposalTypes::Class::Transfer)
			{
				// Get voting results and check if conditions for proposal acceptance are met
				if (!qpi(state.proposals).getVotingSummary(locals.proposalIndex, locals.results))
					continue;

				// The total number of votes needs to be at least the quorum
				if (locals.results.totalVotes < QUORUM)
					continue;

				// The transfer option (1) must have more votes than the no-transfer option (0)
				if (locals.results.optionVoteCount.get(1) < locals.results.optionVoteCount.get(0))
					continue;
				
				// Option for transfer has been accepted?
				if (locals.results.optionVoteCount.get(1) > QUORUM / 2)
				{
					// Prepare log entry and do transfer
					locals.transfer.destination = locals.proposal.transfer.destination;
					locals.transfer.amount = locals.proposal.transfer.amount;
					locals.transfer.tick = qpi.tick();
					copyMemory(locals.transfer.url, locals.proposal.url);
					locals.transfer.success = (qpi.transfer(locals.transfer.destination, locals.transfer.amount) >= 0);

					// Add log entry
					state.latestTransfers.set(state.lastTransfersNextOverwriteIdx, locals.transfer);
					state.lastTransfersNextOverwriteIdx = (state.lastTransfersNextOverwriteIdx + 1) & state.latestTransfers.capacity();
				}
			}
		}
	_

};
```
